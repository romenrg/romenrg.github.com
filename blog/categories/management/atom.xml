<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Management | Blog @romenrg]]></title>
  <link href="https://www.romenrg.com/blog/categories/management/atom.xml" rel="self"/>
  <link href="https://www.romenrg.com/"/>
  <updated>2020-01-12T18:55:47+00:00</updated>
  <id>https://www.romenrg.com/</id>
  <author>
    <name><![CDATA[Romén Rodríguez-Gil]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Everything 'as-code']]></title>
    <link href="https://www.romenrg.com/blog/2019/12/31/everything-as-code/"/>
    <updated>2019-12-31T20:14:00+00:00</updated>
    <id>https://www.romenrg.com/blog/2019/12/31/everything-as-code</id>
    <content type="html"><![CDATA[<p>If you are in the software industry, and specially if you are in the DevOps space, you are probably familiar with the concepts of "Infrastructure as code" and "Configuration as code", which are very popular lately. But, what if that same idea could be applied to everything else in a software company? Aren't documentation and training great candidates for becoming "as-code" as well?</p>

<p><img src="https://www.romenrg.com/images/dwjw2019_lisbon_talk.jpg" alt="Picture taken during the presentation at DWJW 2019. I'm showing the tech stack of the new CloudBees' training platform" /></p>

<p>During 2019 I've been intensively working in this idea at <a href="https://standard.cbu.cloudbees.com/">CloudBees University</a>, along with my colleagues. Nowadays, for our training platform and courses everything is done "as code".</p>

<p>Sounds interesting? Keep reading to learn more about it and/or watch the <a href="https://www.romenrg.com/blog/2019/12/31/everything-as-code/#training-as-code-talk">"Training As Code" talk</a> my colleague Mark Waite and I delivered at DevOps World | Jenkins World in December 2019.</p>

<!-- More -->


<h2>Infrastructure and configuration as code</h2>

<p>Moving infrastructure definition and application configuration to code has been a huge step forward for us as an industry. It has allowed us to automate many "opearions" tasks, saving significant time, reducing human errors and allowing us to have a clear "state" of our software products, their infrastructure and configuration. And it has also contributed to bridge the gap between "development" and "operations", improving collaboration between these teams.</p>

<p>When it comes to tools and technologies, Terraform, Chef, Puppet, Salt, Ansible, Docker and Kubernetes, among others, have played a crucial role in this movement; enabling engineers to describe infrastrucutre and configuration as code.</p>

<h2>How about documentation?</h2>

<p>It's been a while since many technologies and tools have shifted their documentation to code. Many of the most popular open source tools are hosted in GitHub, and typically most of them contain at least a README file in the repo itself, often written in Markdown (but can also be written in alternative languages, such as <a href="http://asciidoc.org/">AsciiDoc</a>).</p>

<p>Also, blogging tools, like <a href="https://jekyllrb.com/">Jekyll</a>, have geared to this concept as well; using Markdown files to represent the different posts, that are later rendered into HTML.</p>

<p>And this trend is also accelerating. Nowadays I see many relevant projects and tools shifting their documentation sites to code. Among the benefits, not only does it allow us to treat everything that belongs (or relates to) a software product equially, but it also improves collaboration between teams. Engineers are much more likely to contribute to documentation if it is written as code, and specially if it is in the very same repo in which the code is. This shift is actually helping to break silos again, as it did between development and operations.</p>

<p>Moreover, having documentation as code makes it easier for us to include documentation-specific stages in our CI/CD pipelines, such as spelling checks or broken links validations.</p>

<h2>Combining these concepts in CloudBees University</h2>

<p>In CloudBees University we offer several courses, most of them focused on <a href="https://jenkins.io/">Jenkins</a> (targeting audiences with different level of knowledge in Jenkins administration or Jenkins Pipelines). Those courses are highly technical and have significant "hands on" pieces. The content is displayed as a website, while for the hands on part, we provide students with lab environments in which they have the different tools they need for the course, with the specific configuration needed for the different exercises they have to complete.</p>

<h3>Everything "as code"</h3>

<p>Needless to say everything is done as code, from our content to the lab environments and their configuration.</p>

<p>Want to know more? Mark and I explained all the details in our talk at DevOps World | Jenkins World 2019, which we recorded and is available here:</p>

<h3 id="training-as-code-talk"> Training As Code: Applying CI & CD to Training Development</h3>




<iframe width="560" height="315" src="https://www.youtube.com/embed/1hda-bVYaVc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<p>As we said during the talk, we are still learning and improving, but it's been a great experience. This approach has allowed us to achieve things that wouldn't have been possible if we were relying on manual tasks. Now we have a single source of truth for everything in CloudBees University, we have peer-reviews for any change we make, clear versioning and history and, of course, fully automated <a href="https://www.romenrg.com/blog/2017/12/31/continuous-integration-delivery-deployment/">CI/CD</a> processes, for integrations and deployments.</p>

<p>Now, how about you? Are you doing "everything as code" already?</p>

<div class="revisions">
  <h2>Significant revisions</h2>
  <p><em>2020, Jan 12</em>: Minor fixes (typos) and addition of examples of docs-specific CI checks.</p>
  <p><em>2020, Jan 11</em>: Major rewrites to the article. First "public" version.</p>
  <p><em>2019, Dec 31</em>: Original draft.</p>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Makes a Great Software Engineer]]></title>
    <link href="https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer/"/>
    <updated>2018-12-29T10:09:00+00:00</updated>
    <id>https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer</id>
    <content type="html"><![CDATA[<p>The software industry has been growing significantly for the last few decades, and this trend seems to only be accelerating.</p>

<p>Due to this fast growth, there has been an ever-increasing demand for software engineers and, since there are not enough developers to meet the demand, many companies often fail to cover their open positions. But, is it also possible that we are looking at the wrong skills when hiring?</p>

<p><img src="https://www.romenrg.com/images/question_unsplash.jpg" alt="Picture of a cofee mug with a question mug" /></p>

<p>Most job descriptions simply list a set of technologies as the necessary “profile” for the open position. However… Aren’t there other skills that could have a higher impact on developer’s success?</p>

<p>Are we looking at the right skills?</p>

<!-- More -->


<h2>Beyond languages and frameworks</h2>

<p>So, despite the shortage of software engineers, we keep seeing, with dismay, that many companies keep restricting their opening positions to people with experience in very specific sets of technologies. Often stating that “X years of experience in <em>&lt;new framework Y></em>” is a key requirement.</p>

<p>Have you though that it's very likely that <a href="https://sizovs.net/2018/12/17/stop-learning-frameworks/">you will not be using <em>&lt;new framework Y></em> in two years</a>? When that happens, which would be the skills your team will need to keep being productive?</p>

<p>It's great to keep an eye on new technologies, of course, as they might bring relevant innovations to our businesses; but focusing mostly on trendy frameworks or on our current tech stack, when hiring, has negative impacts in the long-run and, as a general practice, is very harmful to our industry. We need to move forward. <strong>This focus on languages and frameworks hints there is a fundamental misunderstanding in what makes a great software developer.</strong></p>

<h2>The software industry is evolving constantly</h2>

<p>Granted, if you need an urgent short-term solution for a framework-specific problem, you may want to find someone that knows it deeply. However, more often than not, those short-term needs hide long-term problems in a company.</p>

<p>Developing software is often about making processes more eficient and providing solutions to existing challenges. Also, we now know that due to the fast pace at which both technology and our needs evolve, <a href="https://www.romenrg.com/blog/2015/09/28/why-asking-developers-for-time-estimates-in-software-projects-is-a-terrible-idea-and-how-to-bypass-it-with-scrum/">software development is a continuous process</a>. In most cases software products don’t have an end. We add new features, teams change, companies pivot in their strategy, new technologies bring new opportunities for enhancements, consumer demands change... And we just keep evolving our digital products.</p>

<p>This constant innovation brings constant changes, both in business and in technology. Our products change, as well as the languages, frameworks, tools and devices we use.</p>

<h2>Fortunately, key skills are evergreen</h2>

<p>Isn't there “evergreen” technical knowledge that can be portable across frameworks? Aren't "soft" skills vital? How about code readability, learning-ability and communication skills? Wouldn't those skills be more valuable than framework-specific knowledge in this ever-evolving world?</p>

<h3>It’s not just about technology</h3>

<p>There are skills that often have a higher impact on success than technical knowledge. The so-called "soft" skills (or <a href="https://github.com/romenrg/evergreen-skills-developers#core-skills-aka-soft-skills">core skills</a>) are crucial for any software developer: being able to communicate properly (via email, chat or face-to-face), sharing knowledge with coworkers, engaging in constructive discussions...</p>

<p>Every day more relevant voices in the industry are raising concerns about his. Sam Altman recently shared his <a href="https://twitter.com/sama/status/981690839280771073?lang=en">hiring priorities</a>: values first, aptitude second, specific skills third. Buffer is also a very innovative company in this area, with a <a href="https://open.buffer.com/hiring-process/">culture-fit-based hiring process</a>, where "soft" skills play a key role.</p>

<h3>But there is also technical evergreen knowledge</h3>

<p>Despite the constant change of technology, the technical principles and best practices that also make a software engineer great, are portable across frameworks.</p>

<p>This is a heated discussion. It is indeed difficult to name "fundamentals" or even to draw a line separating technologies that are evergreen from those that are just temporary, as can be seen in the dicussion between <a href="https://twitter.com/zachleat/status/1074776108422307840">Zach Leatherman</a> and <a href="https://twitter.com/seldo/status/1075027798333493249">Laurie Voss</a>.</p>

<p>However, when I refer to "evergreen" technical knowledge, I mean <a href="https://github.com/romenrg/evergreen-skills-developers#general-technical-knowledge">principles</a>, such as OOP and SOLID; data structures, SCM, Clean Code guidelines or DevOps practices.</p>

<h3>The repository of "evergreen" knowledge to the rescue</h3>

<p>So, since 1) nowadays most opennings still focus only on technologies and 2) coming up with the "evergreen" knowledge that we could use for hiring interviews is not trivial, I have gone ahead and created <a href="https://github.com/romenrg/evergreen-skills-developers">this GitHub repository</a>, which goal is to serve as a pool of ideas to condut a fair assessment of skilled software developers / engineers.</p>

<p>As stated in the repository, the purpose of this work is to serve as an alternative resource for conducting hiring interviews of software developers / engineers. It focuses on software development best practices, cross-framework principles and other portable skills; instead of the usual focus on specific languages, frameworks and trends, which tend to quickly become outdated and often don't reflect the real value software developers / engineers bring to the organization.</p>

<p>It is also worth mentioning that it is a work in progress, so important knowledge might be missing, existing bullets can probably be improved and better grouping strategies could be found. For those reasons, any contributions (i.e. PRs) are welcome. Please feel free to propose changes following <a href="https://github.com/romenrg/evergreen-skills-developers/blob/master/CONTRIBUTING.md">the contributing guideline</a>.</p>

<h2>Be the change you want to see in the world</h2>

<p>We all have a role in moving our industry forward. As a manager, think twice when designing the description for your new open position and <a href="https://github.com/romenrg/evergreen-skills-developers">look for ideas beyond a list of technologies</a>; as an individual contributor, when you are asked about the skills your next coworker should have, ask for principles and best-practices; as a candidate, highlight your "evergreen" knowledge and its importance. We owe it to the profession we love.</p>

<p>I have created the <a href="https://github.com/romenrg/evergreen-skills-developers">evergreen skills repository</a> as my two cents' contribution to this discussion. As I wrote before, it is a work in progress, which means there is a lot of room for improvement. I have added contributing guidelines and all constructive PRs are welcome... So I look forward to you contributions!</p>

<div class="revisions">
  <h2>Significant revisions</h2>
  <p><em>2018, Dec 30</em>: Major rewrites to the article. First "public" version.</p>
  <p><em>2018, Dec 29</em>: Original draft published.</p>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Continuous Integration, Delivery and Deployment: Key Differences]]></title>
    <link href="https://www.romenrg.com/blog/2017/12/31/continuous-integration-delivery-deployment/"/>
    <updated>2017-12-31T18:46:00+00:00</updated>
    <id>https://www.romenrg.com/blog/2017/12/31/continuous-integration-delivery-deployment</id>
    <content type="html"><![CDATA[<p>Continuous Integration, Continuous Delivery, and Continuous Deployment are key modern practices in software development. These techniques help us reduce integration problems, automate quality assessment and make deployments much more predictable and less error prone, allowing us to deploy easily and frequently. But… Do you really know the differences between the three?</p>

<p><img src="https://www.romenrg.com/images/two_paths_fork_unsplash.jpg" alt="Picture of a fork in the trail in a forest, leading to two alternative paths" /></p>

<p>The aim of this article is to help clarify what do these techniques mean and highlight the benefits each one provides. We will also analyze which one should be chosen depending on the circumstances.</p>

<!-- More -->


<p>This year I have been deeply involved in the subject, since I have been working on setting up Continuous Integration and Continuous Delivery in <a href="http://www.gobiernodecanarias.org/platino/">Platino</a>, which is a big government project that has been around for almost 10 years. Platino receives tens of millions of requests every month and has a considerable codebase, being composed of more than 50 web services and 9 web applications.</p>

<p>During this time I have realized that, despite the importance of these practices, many professionals in the industry still miss the differences between the three, often talking about them indistinctly in conversations, which creates a lot of confusion around the topic. So, let's check the differences:</p>

<h2>Continuous Integration</h2>

<p>The concept of Continuous Integration (CI) was originally proposed by Grady Booch in 1991 and later integrated into <a href="http://www.extremeprogramming.org/">Extreme Programming</a>. From then on, specially thanks to the <a href="http://agilemanifesto.org/">Agile Software Development</a> movement (as well as <a href="https://www.atlassian.com/devops">DevOps culture</a>), the technique has been widely adopted in the industry.</p>

<h3>Core proposition</h3>

<p>The core proposition of Continuous Integration is associated with Version Control Systems (VCS). It was originally described as a simple technique, which consisted of integrating developers' work (their working copies or branches) to the mainline (<em>trunk</em> in subversion or <em>master</em> branch in git) at least once a day.</p>

<p>The idea behind these daily integrations to the mainline is to reduce integration problems, which are usually caused by the complexity of merging the work of developers that have been working isolatedly for a while. By integrating daily or after each commit, the complexity of the merge process is drastically reduced, as can be seen in the following example:</p>

<p><a href="https://www.romenrg.com/images/branches_without_ci.png"><img src="https://www.romenrg.com/images/branches_without_ci.png" alt="Image of two developers working isolatedly over time, creating several commits before merging" /></a></p>

<p><em>Example of two developers creating several commits in their corresponding branches before merging. Squares represent commits and the circle represents the big merge that has to be made at the end.</em></p>

<p><a href="https://www.romenrg.com/images/branches_ci.png"><img src="https://www.romenrg.com/images/branches_ci.png" alt="Image of two developers applying continuous integration, integrating each change into the mainline" /></a></p>

<p><em>Example of two developers applying the original concept of Continuous Integration, integrating every change into the mainline. As before, squares represent commits and circles represent merges, which are much simpler now, due to the high frequency of integration.</em></p>

<h3>Extended Continuous Integration</h3>

<p>Although the core proposition of CI, described above, has value on itself, <strong>the definition of Continuous Integration was soon broadened</strong>. Nowadays, it often implies the existence of a CI Server (such as <a href="https://jenkins-ci.org/">Jenkins</a>) that, once a new change is made to the mainline of the VCS, executes a <a href="https://jenkins.io/doc/book/pipeline/">Continuous Integration Pipeline</a>. These pipelines are formed of different stages, executed sequentially on every integraton. Their goal, <a href="https://www.martinfowler.com/articles/continuousIntegration.html">as Martin Fowler states</a>, is <strong>to verify every integration with an automated build</strong>, to detect integration errors as quickly as possible. These builds include at least the compilation of the source code and the execution of unit tests, although in many cases other stages such as packaging, execution of integration / end-to-end tests and static code analysis are also included in these Continuous Integration Pipelines.</p>

<p>In this extended definition, the pipeline can either finish successfully or a failure can be produced in any of the stages (tests failing, static analysis not passing a defined threshold….). Usually, in the event of a failure, a notification email is sent to the person that created the last commit (probably the one causing the failure). In such cases, in order to really get the benefits of Continuous Integration, it should be a priority for the team to keep the Continuous Integration status <em>green</em> (passing) instead of <em>red</em> (failing), fixing any problem as soon as it is detected (<a href="https://continuousdelivery.com/foundations/continuous-integration/#faq">ideally in less than 10 minutes</a>).</p>

<p>Following this approach, automated builds with several checks are performed to our code every time we integrate changes, allowing us to detect any issues in an early stage. <strong>This quick detection of problems makes fixing them much cheaper than in traditional approaches</strong>. When these automated builds are not in place, detection of problems tends to occur much later, often during QA or deployment phases, and many times in production, after having deployed the new version. In those cases, days, weeks or even months have passed and developers have switched context, making it difficult for them to remember the particular cases they were working on when the problem was produced. Moreover, the higher pressure for deployment deadlines at those later stages usually leads to poorer solutions, that not only hinder code quality (reducing its readability and mantainability) but also tend to introduce new bugs.</p>

<h2>Continuous Delivery vs Continuous Deployment</h2>

<p>Once Continuous Integration is set, we may decide to continue improving our processes. The next step would be automating deployments to production, making them faster and safer. Here is where the two remaining techniques (Continuous Delivery and Continuous Deployment) subtly differ, as can be see in the following diagram:</p>

<p><a href="https://www.romenrg.com/images/continuous_delivery_vs_deployment.png"><img src="https://www.romenrg.com/images/continuous_delivery_vs_deployment.png" alt="Diagram showing usual stages of Continuous Integration and the differences between Continuous Delivery and Continuous Deployment" /></a></p>

<p><em>Difference between Continuous Delivery and Continuous Deployment</em></p>

<h3>Differences explained</h3>

<p><a href="https://continuousdelivery.com/">Continuous Delivery was described by Jez Humble</a>, as <em>"the ability to get changes of all types [...] into production, or into the hands of users, safely and quickly in a sustainable way"</em>. <strong>Continuous Delivery does not necessarily involve deployment to production on every change</strong>. We just need to ensure that our code is always in a deployable state, so we can deploy it easily whenever we want. On the other hand, Continuous Deployment requires every change to be always deployed automatically, without human intervention.</p>

<p>Thus, as can be seen in the image above, if we decide to enhance the pipeline so that, once the Continuous Integration stages are completed, the new artifact is automatically deployed to production, we talk about <strong>Continuous Deployment</strong>. On the other hand, if we manage to automate everything, but decide to require a human approval in order to proceed with the deployment of the new version, we are talking about <strong>Continuous Delivery</strong>. The difference is subtle, but it has huge implications, making each technique appropriate for different situations, as we will see below.</p>

<p>If you need some other references, appart from this article, to be convinced about this difference, notice that a few years ago <a href="https://puppet.com/blog/continuous-delivery-vs-continuous-deployment-what-s-diff">Puppet published a similar comparison</a> in their blog. Also, <a href="https://www.atlassian.com/continuous-delivery/ci-vs-ci-vs-cd">Atlassian has published a longer article</a> on the topic. I hope these articles help clarify these concepts, avoiding the current confusion with them.</p>

<h3>When is Continuous Deployment recommended and when should we opt for Continuous Delivery?</h3>

<p>In general, <strong>Continuous Deployment is great for B2C products</strong>, since as consumers we are used to the constant change of software products, usually assuming their changes without major problems. In fact, consumer companies such as <a href="https://research.fb.com/publications/continuous-deployment-at-facebook-and-oanda/">Facebook or Netflix follow this approach</a>, deploying small changes several times a day to production.</p>

<p>However, <strong>in B2B products as well as in government projects</strong>, it is <strong>often</strong> necessary to include human control to activate deployments to production. In these cases, our changes may affect people and processes in other companies or departments, making it important for us to announce release dates with enough time, so everybody is able to update their processes, learn to use the new features we are about to release or even adapt their software to our API changes. In this context, applying Continuous Deployment (deploying automatically every change to production) could make other software crash, prevent people from doing their job or even lead to economic and legal issues. That is why for these cases, in which we have to set a fixed deploy date, <strong>Continuous Delivery is the technique of choice</strong>, as is our case in Platino. Following this approach we can also automate the whole process, but we provide human control to execute deployments to production, thus controlling when the new version is released.</p>

<h2>Go ahead!</h2>

<p>As mentioned above, these processes are key elements in modern-day software development and provide a significant competitive advantage to software companies applying them. As we have seen above, depending on the software being developed and its usage, we may not be able to opt for Continuous Deployment, being Continuous Delivery the alternative of choice. However, Continuous Integration is the essential practice that serves as a basis for the other two, making it the preferred choice to start off with.</p>

<div class="revisions">
  <h2>Significant revisions</h2>
  <p><em>2018, Jun 24</em>: Figure 'continuous delivery vs continuous deployment' improved.</p>
  <p><em>2018, May 28</em>: Overall style improvements, rephrasing last section, adding a better description and improving example images.</p>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Programmer Bill Of Rights, Revisited]]></title>
    <link href="https://www.romenrg.com/blog/2016/11/15/the-programmer-bill-of-rights/"/>
    <updated>2016-11-15T18:34:00+00:00</updated>
    <id>https://www.romenrg.com/blog/2016/11/15/the-programmer-bill-of-rights</id>
    <content type="html"><![CDATA[<p>10 years ago, <a href="https://en.wikipedia.org/wiki/Jeff_Atwood">Jeff Atwood</a> wrote an article he titled <a href="https://blog.codinghorror.com/the-programmers-bill-of-rights/">The Programmer Bill of Rights</a>. In that article he described 6 fundamentals that companies should provide for programmers to be successful and work to their full potential, thus maximizing their productivity.</p>

<p><img src="https://www.romenrg.com/images/two_monitors_unsplash.jpg" alt="Picture of a programmers desk with two monitors, one of them showing code" /></p>

<p>Sadly, ten years later, many companies still deny these basics to their developers, even though the business case for these six points is absolutely proved.</p>

<p>In this article, not only would I like to update the original 6 principles, providing further evidence of their importance; but also I would like to extend the list. Based on my experience during the last 10 years, I will propose 4 new fundamentals that I consider absolutelly necessary for the daily work of any programmer, developer or software engineer. Let's get started:</p>

<!-- More -->


<h2>10 Fundamental Programmer Rights (6 + 4)</h2>

<p>It is worth mentioning that, despite the headline, <em>this article does not refer to general Labor Rights, since those are usually well-known and its compliance is required by law. This article focuses only on aspects that are specific to software development</em>, aspects that are usually not regulated, but have a huge impact on programmers' daily work.</p>

<h3>The 6 Original Rights proposed by Jeff</h3>

<ol>
<li><p><strong>Every programmer shall have two decent monitors</strong>. <br/>
Apart from the scientific studies Jeff linked in his article in 2006, <a href="http://techreport.com/news/14343/more-bigger-monitors-boost-productivity-says-study">many others have emerged more recently</a>, proving the productivity benefits of having two monitors while programming. <a href="http://www.computerweekly.com/news/2240088457/Multiple-monitors-boost-productivity-by-355">Some studies even suggest having three monitors</a>.
However, I have met some engineers that prefer to choose one big (27”) monitor rather than two smaller ones; and that should definitely be OK if that is her preferred set-up. <em>The key here is that companies should be wise enough to provide developers with the tools they need to take their productivity to the maximum.</em>
Also, developers working on User Interfaces and graphic designers care a lot about other characteristics such as colors or bright; so again, it is not just about the screen size, it is about taking your employee into account when providing the tools he needs to perform his job in the best possible way.
How is it possible that some companies do not pay attention to this at all? As many people pointed out in <a href="http://developers.slashdot.org/story/11/05/16/1957210/do-developers-really-need-a-second-monitor">this slashdot discussion about the topic</a>, the cost of a decent monitor may be around $150 - $200 nowadays. That is a ridiculous amount compared to <a href="http://money.usnews.com/careers/best-jobs/software-developer/salary">the salary of a developer</a>… So it cannot be about the money; since we know that the productivity increase would pay off in just a few days. Sadly, refusals from management to provide the right tools to employees are a clear sign of toxic management or toxic company culture and <a href="#toxic-management-denying-rights">if you find yourself in that situation, you should consider looking for a new job <em>ASAP</em></a>.</p></li>
<li><p><strong>Every programmer shall have a fast PC</strong>. <br/>
Although this claim still makes total sense, I think this one is one of the easiest-to-get for management and non-tech people, since everybody has suffered a slow pc and can relate to it more easily. However, I have seen cases in which developers have to connect to a remote machine using a remote desktop. This may cause some performance issues, as well as other problems such as non-functioning shortcuts or hardware compatibility problems. Unless there is a very clear reason to use a Remote Desktop, it should be avoided. As Jeff stated 10 years ago, every developer should have a fast computer that allows her to do all she needs to get her job done.</p></li>
<li><p><strong>Every programmer shall have their choice of mouse and keyboard</strong>. <br/>
To be honest, I’m not especially picky with mouse and keyboard, but some developers are… So if you are a manager and one of your developers complains about his keyboard and mouse… Do not waste any time thinking, we are probably talking about less than $50 here. It’s not worth discussing. If his choices are very specific or expensive, at least allow him to bring his own keyboard and mouse from home. Diversity in a company is enriching, so don’t try to treat all your employees as if they were clones.</p></li>
<li><p><strong>Every programmer shall have a comfortable chair</strong>. <br/>
I hope this is obvious to everybody in 2016. <a href="http://ergo.human.cornell.edu/AHTutorials/chairch.html">Having an ergonomic chair and sitting correctly is a health issue</a>. In fact, many countries have already created <a href="http://www.hse.gov.uk/pubns/priced/hsg57.pdf">health-and-safety regulations for office chairs</a>. Moreover, money is not a big deal either now, since <a href="http://www.ikea.com/us/en/catalog/products/00103102/">there are good chairs for $200</a>. Also, it is worth mentioning that in recent years the <a href="http://ergonomics.about.com/od/office/a/Benefits-of-a-Standing-Desk.htm">benefits of standing desks</a> have become popular, so it could be something to consider. Once again, when it comes to the tools to be used on a daily basis at work, like chairs, the best approach would be to involve employees in the decision. We all may have different preferences, based on our height, weight, back problems, etc…</p></li>
<li><p><strong>Every programmer shall have a fast internet connection</strong>. <br/>
For this claim, the same as in the “fast PC” sections has happened. Apart from the widespread access to broadband internet at low prices; services like Youtube, Netflix, online games and Skype/Hangouts video-calls have made us a great favour. Thanks to them many non-technical managers have realised about the importance of a fast internet connection, making it a default in most companies.</p></li>
<li><p><strong>Every programmer shall have quiet working conditions</strong>. <br/>
This is a tricky one. Nowadays most offices are open-plan. Moreover, collaboration is encouraged in agile teams. All this makes it difficult to keep quiet working conditions for us to concentrate. Many <a href="https://twitter.com/jasonfried/status/794212152206729216">relevant people in the industry are raising concerns about this</a>. However, <a href="https://hbr.org/2015/03/stop-noise-from-ruining-your-open-office">there are some things we can do</a>, such as having (and using) meeting rooms, having white noise generators to mask voices, wearing headphones to concentrate (which I usually do) and/or use an indicator to show coworkers if you can or cannot be interrupted. Even though many jobs require concentration, getting to “flow state” is vital to accomplish most programming tasks, as Jeff mentions.</p></li>
</ol>


<h3>My 4 Proposed Additions</h3>

<ol>
<li><p><strong>Every programmer shall be free to choose her preferred IDE</strong>. <br/>
In the past it was common to have the build and/or deploy process of the application being developed attached to the IDE (usually by means of a plugin). Fortunately, nowadays the use of build tools has become mainstream, making our build processes IDE-independent. For example, in the Java community, build tools like maven or gradle make it possible for developers in a team to use different IDEs such as Eclipse, Intellij IDEA or any other editors, without any problems of collaboration. They just need to use a version control system (such as Subversion or Git) to share changes and a build tool to generate artifacts. In such environment, forcing developers to use an standardized IDE seems to be only a poor resource of old-school managers used to the “command-and-control” approach to impose their rule. That imposition can only cause a low morale among team members, decrease motivation and cause brain drain in the team, since many talented developers will leave to a more open-minded company.</p></li>
<li><p><strong>Every programmer shall have admin rights on his computer</strong>. <br/>
Last year I was introduced to a company that had recently been created with the idea to enter in the software development market. However, I was utterly surprised when I got to know that this company didn’t allow developers to have admin rights in their computers. This is pure nonsense. <a href="https://stackoverflow.com/a/701361">As this fantastic answer in Stack Overflow states</a>, developers in their daily work need to install software for different development purposes (editors, servers, databases, API clients...), they need to change different system configurations for different purposes and, most importantly, they need to be comfortable at work in order to give the best of themselves. Restricting admin rights to developers will only lead to a high turnover rate, inability to retain competent people, poor morale and poor quality delivery. Probably, <a href="http://stackoverflow.com/questions/701214/should-developers-have-administrator-permissions-on-their-pc#comment526142_701214">as this other comment states</a>, "if you walk into a job as a developer and find you have no admin rights in your machine, the best choice is to not come back the next day".</p></li>
<li><p><strong>Every programmer shall have access to the big picture</strong>. <br/>
Sometimes programmers are not presented with the big picture of the system they are contributing to build, but instead they are given small tasks to do, with narrow descriptions. In those cases, they often do not have direct access to the product owner nor the end users of the software they are working on. This usually causes trouble, since many wrong decisions can be made and many misconceptions can be created. To design software that can evolve properly in the desired direction, developers should understand the big picture, the whole system that is being built, not only the small task that has been assigned to them at one point. Moreover, developers should be free to ask as many functional questions as they need, so they can make the right design decisions and write software that can evolve as expected, avoiding later problems.</p></li>
<li><p><strong>Every programmer shall have autonomy in his daily work</strong>. <br/>
As any other creative process, programming requires autonomy. That is why agile frameworks, like <a href="https://en.wikipedia.org/wiki/Scrum_(software_development)">Scrum</a>, propose planning work for periods of a week, 15 days or a month; so developers can organize themselves in between. Daily meetings can help detect and resolve problems, as well as keep the development team in sync; but freedom for each contributor to organize his workday without suffering micromanagement should be preserved. The need for autonomy also applies to the programming process, where creativity is key to problem-solving. Some developers prefer to solve a task by creating some tests first, others build a monolithic function and then refactor it, others start by understanding the existing codebase and doing some diagrams... Any of these approaches should be respected, as long as basic agreements of the team (e.g. <em>"definition of done"</em>) and quality standards (e.g. <em>minimum test coverage</em>) are met.</p></li>
</ol>


<p><em>What do you think about these additions? Please, join the conversation!</em> <br/> <em>Are these rights being respected at your company?</em></p>

<blockquote><h3><a name="toxic-management-denying-rights">A real case of toxic management denying many of these rights</a></h3>

<p>Unfortunately, there are companies that keep denying many of these basics today.</p>

<p>I recently saw a case in which a manager refused to replace a defective monitor with obvious flickering problems to an employee (even though flickering may cause dizziness, fatigue and headaches). This very manager was also forcing programmers to work with only one squared 19” monitor (for no reason). He firmly refused to buy second monitors and even forbade some developers to bring a second monitor from their homes… Does it make any sense? However, this guy had two wide monitors in his desk, of course. I guess he just wanted to show that there was a big difference between him and his “subordinates”, who had to be controlled and treated like clones.</p>

<p>As with any other of these rights, a reluctance to provide programmers with two monitors not only shows that your manager or the company board do not care about your opinions or comfort; they don’t even care about productivity. It is definitely a red flag. Taking into account the ridiculously small cost of monitors nowadays, even worrying about it shows a clear case of being “penny wise, pound foolish”.</p>

<p>But that’s not all of it. Usually, when an old-school command-and-control minded manager is violating one of these basics, is probably violating many others, since they are all tightly-linked and it is all about mindset and company culture.</p>

<p>In this particular case, this very manager was also forcing developers to use a three-year-outdated version of Netbeans as IDE, with no front-end support (significantly diminishing their productivity). And, by the way, he had also decided to forbid admin rights to programmers in their own machines (making their daily work absurdly complicated)... So you see, three basics at once. Not to mention that micro-management was also one of the company core values. The micro-manager used to interrupt programmers every hour to closely control their tasks, taking away all the autonomy and long-term vision from the developer.</p>

<p>If you find yourself in a case like this one, my advice cannot be clearer: there are many companies that will be glad to provide the tools you need to achieve the best results in your daily work, so don’t wait anymore, move on. No one should work for a tyrant like that.</p></blockquote>

<p>As an ending to this article, I would like to borrow the last paragraph from Jeff’s article: “The few basic rights we're asking for are easy. They aren't extravagant demands. They're fundamental to the quality of work life for a software developer. If the company you work for isn't getting it right, making it right is neither expensive nor difficult. <strong>Demand your rights as a programmer!</strong> And remember: you can either change your company, or you can <em>change your company</em>”.</p>

<div class="revisions">
  <h2>Significant revisions</h2>
  <p><em>2018, Apr 27</em>: Clarified the last two 'rights', improving grammar and style. Minor corrections in the example section were also included.</p>
  <p><em>2016, Nov 15</em>: Original version published.</p>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why asking software developers for time estimates is a terrible idea and how to bypass it]]></title>
    <link href="https://www.romenrg.com/blog/2015/09/28/why-asking-developers-for-time-estimates-in-software-projects-is-a-terrible-idea-and-how-to-bypass-it-with-scrum/"/>
    <updated>2015-09-28T11:17:00+01:00</updated>
    <id>https://www.romenrg.com/blog/2015/09/28/why-asking-developers-for-time-estimates-in-software-projects-is-a-terrible-idea-and-how-to-bypass-it-with-scrum</id>
    <content type="html"><![CDATA[<p>I have worked in many software projects and have been lucky to be in the initial team of several software products. Besides, having acted both as a Developer and as a Product Manager has allowed me to have a wider view of what usually causes most friction between business and engineering: time estimates.</p>

<p><img src="https://www.romenrg.com/images/scrum_software_estimates_reverse_engineering_pixabay.jpg" alt="Picture of a woman pointing to her watch as if you were late. Typical management or customer reaction to delayed software projects" /></p>

<p>It usually starts with managers or customers asking “when will &lt;this idea> be ready?” and it is usually followed by developers racking their brains to give a specific date... Needless to say, that date is likely to be <em>dreadfully wrong</em>, as it is the norm in the industry. There is a near-total inability of developers to predict how long a project will take, so time estimates are usually worthless.</p>

<p>However, applying <a href="http://www.scrumguides.org/">Scrum</a> along with some <a href="http://www.extremeprogramming.org/rules.html">XP</a> practices we can avoid the uncomfortable tension of asking developers for time estimates. Instead, we can calculate release dates automatically, getting infinitely more accurate time estimates, while saving all the arguments and keeping team morale high. How? Keep reading!</p>

<!-- More -->


<h2>1. The problem: Time estimates in Software Projects fail dramatically</h2>

<p>The topic of delay and over-budget in the software industry has been widely discussed, including reports such as <a href="https://hbr.org/2011/09/why-your-it-project-may-be-riskier-than-you-think/ar">this one</a> by Harvard Business Review, later commented in this <a href="http://www.infoq.com/news/2011/10/risky-it-projects">InfoQ post</a>. A conclusion of this report is: <em>“If you want to avoid the slow death caused by IT projects you must be prepared not only to spend 400% more than planned on the project, but to reap only 25% of the expected benefits. If you keep this in mind you can possibly prevent a company from being killed by an IT project”</em>.</p>

<p>Moreover, since 1994 <a href="http://standishgroup.com/">Standish Group</a> has been releasing their <a href="http://blog.standishgroup.com/post/50">CHAOS Reports</a> every year. These reports are a relevant snapshot of the state of the software development industry. <a href="http://www.infoq.com/articles/standish-chaos-2015">The last CHAOS Report (2015)</a>, shows that <em>even nowadays, only 29% of Software Projects are successful (defined as on-time, on-budget and with a satisfactory result)</em>. This report highlights one of the key variables affecting success rates: the approach used to manage projects (Agile vs Waterfall). <em>Agile approaches showed a 39% ratio of successful projects, while Waterfall only 11%</em>. This seems to be closely related to the way in which we deal with estimates and changes in each case.</p>

<h3>1.1. Let’s assume we never know how long it’s going to take</h3>

<p>I bet some of you consider yourselves great estimators. However, the overconfidence of software developers is a well-known issue. Dan Milstein describes it <a href="http://blog.hut8labs.com/coding-fast-and-slow.html">in this great article</a>, concluding that "one of the deepest challenges involved in writing software is <em>the near-total inability of developers to predict how long a project will take</em>”. In this article, Dan writes in detail about all the issues that make software projects so hard to estimate. Among others, factors such as the impossibility to write fully detailed specifications (as he says, to do so you have to be actually writing the software), uncertainty and unpredictability (about the product itself, the market, the technologies being used...) and the uniqueness of software projects (which makes it almost impossible to relate to similar projects for estimates since there are always major differences).</p>

<p>Moreover, <a href="https://news.ycombinator.com/item?id=5596578">in this Hacker News thread</a>, <em>many developers acknowledge "lying" when giving estimates</em>, which is considered an standard practice to deal with customers or management. In the same thread, another interesting recommendation for management is to add <em>a load factor of 2-5x to developer estimates</em>, describing it also as an “industry standard”. As you may guess, these practices are not helping the industry to improve, but rather the opposite. Should we keep ignoring the elephant in the room?</p>

<h3>1.2. Do we really need time estimates?</h3>

<p>There is an increasing tendency among developers against giving estimates in software projects (see <a href="https://twitter.com/hashtag/NoEstimates">#NoEstimates</a>). To a certain extent this makes total sense, since time estimates have been proved to fail dramatically in the industry (<a href="https://coding.abel.nu/2012/06/programmer-time-translation-table/">especially for tasks that take more than a day</a> to complete). Besides, developers are usually the ones paying the bill of a failed estimate, by working long hours and suffering great stress due to management pressure to meet deadlines. This usually leads to poor team morale, friction, loss of credibility and many other problems, as described in detail by Richard Clayton in his article “<a href="https://rclayton.silvrback.com/software-estimation-is-a-losing-game">Software Estimation is a losing game</a>”.</p>

<p>On the other hand, since I have been manager and CEO apart from developer, I know how useful would time estimates be from the business side (either to calculate costs for a customer that wants a fixed-price contract; or to ourselves, to plan marketing actions, meetings, etc...). <em>However, we must asume that calculating accurate time estimates for software projects is simply not possible</em>. Putting pressure on developers to give us time estimates will simply make them lie to us, giving a virtually random estimate that is going to be dreadfully wrong. As we have explained before, <em>they just don’t know how long it is going to take</em>.</p>

<p>I guess I don't need to mention that, if developers are not able to give us an accurate time estimate for a software project to be finished in; managers (with no technical background or having spent the last few years out of development) are much worse at it.</p>

<p>So, at this point, as a manager it is worth taking some time to think if we really need to estimate the whole project (or backlog). Maybe we could follow an alternative approach, especially if we own the product we are building. For instance, some innovative companies, such as <a href="https://m.signalvnoise.com/how-we-set-up-our-work-cbce3d3d9cae">Basecamp</a> or <a href="https://open.buffer.com/6-week-cycles/">Buffer</a> are avoiding long term planning and estimation by working on 6-week cycles. They always focus on the most valuable user stories, adjusting scope to make sure a releaseable version is ready at the end of each cycle.</p>

<h3>1.3 The role of evil contracts</h3>

<p>If there is something to blame above anything else, that would be the magic <em>fixed-everything contract</em> (where price, time and scope are set at the beginning of the project). Those contracts are the root of all evil. The recipe for disaster starts by "setting the cost" of development beforehand (when we know the least about the software being built) and presenting it to the customer in the form of a contract. This contract will describe how a "fixed software" (that in most cases is just a vague idea) will be developed for a fixed price and, of course, ready for a fixed date.</p>

<p>That is how all this madness usually starts.</p>

<p>Most managers and salespeople love this approach. It seems so simple... To "calculate the cost" they just have to ask developers for time estimates, add some contingency time and then do the math (calculating salaries, other expenses, benefits...) and that's it! Ready to convince the customer! What can go wrong?</p>

<p>Well, now that you know that having accurate time estimates for software projects is simply not possible, as a manager you can <a href="https://www.youtube.com/playlist?list=PLhE6PVDdZ3dLSS42FLcwYLcH3pldS71MT">choose more realistic contract approaches</a>, or you can <a href="http://blog.salsitasoft.com/why-we-dont-do-fixed-price-software-projects/">assume the risks of doing fixed-everything contracts</a>, based on those more-than-likely-wrong time estimates. But if you choose the latter, don’t blame developers when deadlines are not met.</p>

<p>If you have a team of professional and commited developers, they will be doing their best all the time, trying to do things as quickly as they can (as <a href="https://twitter.com/dhh">@dhh</a> says, <a href="https://twitter.com/dhh/status/584745462445518848">ASAP is implied</a>). Sadly, too many times managers end up using the whip to make developers achieve the impossible. At the end, the imposible is not achieved, software quality goes down because of the rush (causing more delays due to constant bugfixing and poor code-maintainability), team morale is almost zero, everyone suffers burnout and the customer gets angry. Nobody wins.</p>

<p>However, even using these evil contracts, you can always follow an iterative and incremental development process internally, making sure your team is always working on the most important features and releasing an extended version of the product every few weeks. By doing this, you will always have working software to ship to your customer. If the deadline arrives and the project is not finished, at least the X more important features will be developed. And working software will be available. Moreover, if you manage to involve your customer in the process, you will benefit from showing her the incremental releases. Among other things, you will get valuable feedback, anticipate changes and build trust. Therefore, customer relationships will improve and contract changes will become easier to deal with.</p>

<h2>2. An alternative solution to estimate Release Dates</h2>

<p>So, if you are still forced to provide long term release dates, an alternative way to calculate them will be described in this section. This approach is based on combining Scrum with some XP concepts, such as Velocity and User Stories; as well as using effort-based Story Points.</p>

<p>Unfortunately, Scrum has become kind of a buzzword in the last few years and many people in the software industry say they use Scrum when in reality they are not following many of its key principles... If you are new to Scrum, I encourage you to read <a href="http://www.scrumguides.org/">The Scrum Guide</a> which is a fantastic 16-pages document written by the creators of the framework describing its principles. You can also find information on XP practices <a href="http://www.extremeprogramming.org/rules.html">here</a>. Too tired to read? Then a good alternative are these <a href="http://scrumtrainingseries.com/">great videos about the scrum framework</a>.</p>

<p>Although I think Scrum is a great framework for software development, I agree with <a href="https://twitter.com/jasonfried/status/700746928020176896">Jason Fried</a> and <a href="http://www.agile-doctor.com/2016/03/10/maybe-time-stop-using-word-sprint/">some others</a> that are showing <em>concerns about the word 'sprint'</em>. As they have highlighted, this term can be misinterpreted, leading to behaviors that go against sustainable development, a core <a href="http://agilemanifesto.org/principles.html">agile principle</a>. For that reason, in this article <em>I have decided to use the word 'cycle' instead.</em></p>

<p>Having these definitions clear, all you need to do to get more accurate release dates for your software project is to follow 4 simple steps I will describe below. Since you won't have to ask developers for time estimates, you will avoid many misunderstandings. Besides, this approach allows you to rearrange the product backlog anytime (adding, removing or moving stories), getting approximate release dates automatically.</p>

<h3>2.1. Create a Product Backlog with User Stories as a first step</h3>

<p>Not asking anything to developers yet; no coding. Sit down with your product team, potential users or customers and try to describe what you think the product should be, according to what you have learned so far. If you haven't done it yet, creating some <a href="http://designmodo.com/wireframing-prototyping-mockuping/">simple wireframes</a>, discussing them lightly and iterating a bit over them is usually the best way to start. But keep it simple, following <a href="http://theleanstartup.com/principles">Lean Startup</a> advice. This exercise will help you with <a href="https://steveblank.com/2014/06/28/customer-discovery-the-search-for-productmarket-fit-2-minutes-to-see-why/">customer discovery</a>, clarifying your initial hypotheses.</p>

<p>So, once you have enough information about the product and its market to do so, define some core <a href="https://www.scrumalliance.org/community/articles/2010/april/new-to-user-stories">User Stories</a> and prioritize them, creating a Product Backlog for your <em>Minimum Viable Product</em> (MVP). It should represent a basic version that you are able to release quickly, to get feedback from the market and keep learning and adapting, following an iterative and incremental development process. Since user stories are about functionality, wireframes are usually very good help. They can be added as part of their Acceptance Criteria.</p>

<p>My favourite tool for managing Scrum is <a href="https://es.atlassian.com/software/jira/agile">Jira</a>, which includes a great backlog-management tool. However, there are many other tools available, including <a href="https://trello.com/">Trello</a>, which I also use as a kanban board for smaller projects. For wireframing, there are also many good tools available. One of my favourites is <a href="http://wireframesketcher.com/">WireframeSketcher</a>, due to its IDE and CVS integration. <a href="https://balsamiq.com/">Balsamiq</a> and <a href="https://moqups.com/">Moqups</a> are great alternatives too.</p>

<p>After creating the initial Product Backlog, you will have a much clearer picture of the MVP you are going to build; therefore, you will be in a better position to present it to developers.</p>

<h3>2.2. Estimate all User Stories in the backlog based on effort points</h3>

<p>Once you have created your initial Product Backlog and prioritized User Stories, it is time to have the first Product Backlog Refinement meeting with the Scrum Team (which includes the Development Team). Our goal would be to estimate all User Stories in the Backlog, but instead of time we will be using effort points. Each user story will have X points. A common approach is to use the Fibonacci scale for those points.</p>

<p>Since it is very important to be consistent when estimating user stories, I usually encourage the team to <em>find the easiest user story in the backlog and give it a 1 and then find the hardest one and give it either a 13 or a 21</em>. That way you have created the team’s effort scale, making it easier to estimate the remaining user stories based on a scale that is totally dependent on the project.</p>

<p>“But those effort-points are not useful for me!”, a manager said. Please, hold on. They definitely are. For now they tell you which are the easiest user stories and which ones are the hardest. But even better, in a few cycles they will help you estimate when might the project be finished or when will a specific user story probably be done, according to its place in the backlog. And this estimate will be much more precise than any you could get from asking developers for time estimates.</p>

<p>If in the future new user stories appear <em>(they will)</em>, all you have to do is add them to the backlog, placing them according to their relative priority compared to the rest; and save some time to conduct a backlog refinement meeting, in which the new stories will be estimated. The most important task of the Product Owner (your role in Scrum) is to keep the backlog updated, estimated and prioritized; in order to make it useful for predicting possible release dates.</p>

<h3>2.3. Keep effort-based estimates time-independent</h3>

<p>Even though agile implementations usually replace time estimates by effort points (using scales such as Fibonacci or t-shirt sizes), some managers simply establish a link from those points or sizes to "their equivalent" in time. And they usually do that publicly, which means that everybody goes back to time estimates, thus ruining the whole thing again and making developers hate agile too (even though what they hate is a bad implementation of agile frameworks).</p>

<p><em>The key of using an effort-based system for story points is precisely to keep estimates separated from time</em>. The relative "effort" of a task is a much easier concept to analyze for developers, especially when comparing different user stories of a project. Moreover, estimating effort instead of time prevents common conflicts, mostly related to considering time estimates a "contract". As we have seen before, developers simply cannot estimate how long a software project is going to take. Linking effort points to their "time equivalent" will only lead to poor team morale, friction and false expectations, as we have seen before. Avoid that. There is another way to get to time estimates: indirectly!</p>

<h3>2.4. In the first few cycles Team Velocity is yet unknown</h3>

<p>When planning a cycle <em>(sprint)</em>, the team will pick user stories from the top of the backlog until they consider it is enough work for the new cycle. Having a shared <a href="https://www.scrumalliance.org/community/articles/2008/september/what-is-definition-of-done-(dod)">Definition of Done</a> can help planning, making sure all team members are aware of all the tasks that have to be completed for each story to be "done".</p>

<p>Then, during the cycle review you will discover whether all user stories were completed as expected or if there were some changes (e.g. the team was not able to complete all user stories, or by constrast, all stories were completed early and some more were added to the cycle).</p>

<p>As you will see, in the first few cycles there are usually some differences when comparing what the team planned to achieve and what it did actually achieve. However, this error tends to become smaller over time, achieving a similar pace, measured in number of story-points completed per cycle. This metric is often referred to as <em>Team Velocity</em>.</p>

<p>It is worth highlighting the importance of minimizing changes related to team members (eg. replacing someone or changing her dedication). Any change of this sort will have a significant impact on velocity, which would undermine our capacity to forecast release dates.</p>

<h3>2.5 After a few cycles you will be able to estimate release dates, based on Team Velocity</h3>

<p>So, once a few cycles <em>(sprints)</em> have passed, you will realize that if the team and its story-point estimates have remained consistent, the number of story points being completed per cycle (Team Velocity) is similar.</p>

<p>Since you have been doing your job of keeping the backlog updated, prioritized and estimated in story points, now you will able to forecast when will a particular story be finished.</p>

<p><em>An <strong>example</strong> will make it clearer:</em></p>

<p><em>Let’s say our development team is applying the strategy described in this post. It is completing about 25 points per cycle and each cycle is 15 days long. If you want to know when will a particular user story be finished, all you need to do is count the number of story points that are above it in the backlog, add its own story points and do some simple math:</em></p>

<p><a href="https://www.romenrg.com/images/story_points_estimates_backlog_example.png"><img src="https://www.romenrg.com/images/story_points_estimates_backlog_example.png" alt="Example showing a backlog with story points, estimated based on effort; team velocity, cycle duration and a forecast for a particular story" /></a></p>

<p><em>In this example, user story X has 52 points above it in the backlog and has 5 points itself. This means a total of 57 story points have to be completed for story X to be finished. Since in each cycle the team is completing approximately 25 points, the story you are looking for will probably be finished in 3 cycles time, meaning it would be deployed in about 45 days.</em></p>

<p>The same process can be applied to guess when could the whole project be finished, just taking the last user story you have in the backlog for the calculations explained before.</p>

<h2>Conclusion</h2>

<p>There is no silver bullet in software estimation. However, if you need to prepare marketing actions or respond to a customer, you will probably need at least a rough idea of delivery dates. Following the management approach described in this article, you will get time estimates without asking for them; you will keep team morale high, avoid burnout and improve productivity. Besides, you will be able to automatically forecast the impact of changes in the timing of the project.</p>

<p>This solution contributes to improve business-engineering relationship, improve software quality and reduce costs in the long-run. Besides, if you involve customers in the process, their understanding and trust may improve considerably, making it easier for both parties to deal with change, preventing many deadline-related conflicts.</p>

<p>Now, join the conversation: How do you deal with time estimates in your company?</p>

<div class="revisions">
  <h2>Significant revisions</h2>
  <p><em>2018, May 06</em>: Added an image to the example and improved its description.</p>
  <p><em>2018, May 01</em>: References to 6-week cycles followed by Basecamp and Buffer are included. Also, replaced the term "sprint" by "cycle", which seems more appropriate to encourage working at a sustainable pace.</p>
  <p><em>2018, Apr 17</em>: Improving title and meta description.</p>
  <p><em>2015, Sep 28</em>: Original version published.</p>
</div>

]]></content>
  </entry>
  
</feed>
